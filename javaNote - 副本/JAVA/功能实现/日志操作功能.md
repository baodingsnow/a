> 思路：
>
> 
>
> 插入日志的时候也要插入id versionid
>
> 更新操作：list盛放所有修改过的日志。包括三个字段 ：字段名。中文名，操作信息
>
> 







> ①在日志操作表里添加id，versionId两个字段，根据id，versionid查出一个数据的操作日志
>
> ②对插入的操作记录进行排序  得到一个list  然后遍历，查找出每条数据的上一条数据
>③对上面的每组数据进行反序列化后然后比较



> 第1步  写个公共方法对查询的数据进行比较
>
> 新增、删除一个方法    编辑一个方法
>
> 编辑方法：创建一个list 用于盛放中文名、信息、字段名称三个字段  
>
> 最后将list序列化 塞入oper_param字段中







>  第二步
>
> 将日志操作的各个信息塞到对应的字段中
>
> 







> 问题
>
> 需要两个操作日志对象去调用比较方法  怎么获取





invoke方法

> 只需要输入参数，我可以调用替代各种方法，在未知的情况下，根据条件决定去调用什么对象，什么方法



# 序列化和反序列化

 一般都是将实体类序列化成json  方便存入到数据库。

用到的场景：设计的数据库表中有个大字段，比如说主机字段，里面需要两个固定内容 ：内存和处理器。再设计一张表进行查询效率就很低了。通常采取的方法是，创建一个主机实体但不设计表字段。在dto里加入内存和处理器属性，然后以对象的形式存到这个表中。





反序列化

```java
   List<NoticeConfigureDto> noticeConfigureList = JSON.parseArray(soaPublishExtendfiled.getNoticeConfigure(), NoticeConfigureDto.class);
                List<TimerTriggerDto> timerTriggerList = JSON.parseArray(soaPublishExtendfiled.getTimerTrigger(), TimerTriggerDto.class);
                List<ParamConfigureDto> paramConfigurationList = JSON.parseArray(soaPublishExtendfiled.getParamConfigure(), ParamConfigureDto.class);
```









# 
