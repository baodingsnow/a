# 什么是单例模式



最简单的设计模式。只有且必须有一个自己创建的实例。

特点

私有构造函数:为了确保只有一个实例，这个类不能被实例化，否则就会产生多个实例

自行创建实例:创建一个方法获取唯一的实例





单例模式应用场景：windows任务管理器、

-  Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。

- 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗。



单例模式应用的场景一般发现在以下条件下：

（1）资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。

（2）控制资源的情况下，方便资源之间的互相通信。





> 我的理解  在类中定义好获取实例的方法，单例模式只允许一个实例存在，所以将构造方法私有化，只允许外部类通过调用获取实例方法来获取实例



# 单例模式的几种实现方式

## 1.饿汉式

饿汉式代码很简单，就是定义了一个私有的静态字段，在我们类加载的时候初始化instance，然后提供一个getInstance()方法给外部访问我们的这个实例，



## 2.懒汉式，线程不安全

懒汉式比饿汉式的稍微复杂了点，但还是非常简单，首先还是定义一个私有的静态字段，只不过在getInstance()方法里面多了一重判断，判断当前的这个instance是否为空，如果是null，就代表在当前应用程序中还未存在这个实例，就先初始化出来，如果有就直接返回当前实例

这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。

### 懒汉式，线程安全

这个得加锁

拿卖电影票为例，需要在判断电影票是否为空前加上锁，因为线程执行过程需要等待其他线程执行完程序;

缺点:每次只能有一个线程去执行，那就代表其它线程只能阻塞挂起

优化:先判断是否为空再加锁，这样票卖完了，大家(线程)都可以离开，而不是在排队接收票没了的消息。

加锁后需要再判断一次是否为空，上一次判断是为了告诉大家有没有票(相当于开场)，有票后就需要再次排队，排到的线程还得问现在有没有票（其实也不算太完美）

## 总结

饿汉式与懒汉式的区别就是饿汉式每次加载这个Singleton类的时候，就会先去初始化被static修饰的变量，有的时候我们可能只需要调用一下这个类中的某个方法，那就会造成浪费空间，浪费内存

懒汉式只有调用获取实例的方法时，才会创造实例。