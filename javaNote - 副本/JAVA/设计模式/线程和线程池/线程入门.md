# 线程

线程是进程中实施调度和分派的基本单位。

java用监视器机制实现了线程之间的同步执行

## 创建线程的三种方法

```
继承Thread类创建线程类
通过Runnable接口创建线程类
通过Callable和Future创建线程
常用Runnable
```

### **继承Thread类**

　　 （1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。

　　（2）创建Thread子类的实例，即创建了线程对象。

　　（3）调用线程对象的start()方法来启动该线程。

```java
package Thread;

import java.util.concurrent.*;

public class TestThread {
    public static void main(String[] args) throws Exception {
        testExtends();
    }

    public static void testExtends() throws Exception {
        Thread t1 = new MyThreadExtends();
        Thread t2 = new MyThreadExtends();
        t1.start();
        t2.start();
    }
}

class MyThreadExtends extends Thread {
    @Override
    public void run() {
        System.out.println("通过继承Thread，线程号:" + currentThread().getName());
    }
}
```



### **实现Runnable接口**　

（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 

（2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 

（3）调用线程对象的start()方法来启动该线程。·

```java
package Thread;

import java.util.concurrent.*;
//测试类
public class TestThread {
    public static void main(String[] args) throws Exception {
         testImplents();
    }

    public static void testImplents() throws Exception {
        MyThreadImplements myThreadImplements = new MyThreadImplements();
        Thread t1 = new Thread(myThreadImplements);
        Thread t2 = new Thread(myThreadImplements, "my thread -2");
        t1.start();
        t2.start();
    }
}
//线程类
class MyThreadImplements implements Runnable {
    @Override
    public void run() {
        System.out.println("通过实现Runable，线程号:" + Thread.currentThread().getName());
    }
}
```

- **采用实现Runnable接口方式：**

　　　（1）优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。
　　　（2）缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。





只写了两种最常见的方式，另外实现runnable最常见



> 还有一种是由第二种变形而来的直接new Runnable(){}，我们都知道java的接口是不可以实例化的，但代码中的new Runnable(){xxx}确是实例化了，为什么？ 接口和抽象类不可以实例化是对的，这个是java语法规范来的，**而new Runnable(){}其实不是实例化Runnable接口来的，实际上一种内部类的一种简写** 在这里： 
>
> ①首先构造了一个”implements Runnable “的无名local内部类(方法内的内部类) 
>
> ②然后构造了这个无名local内部类的一个实例 
>
> ③然后用Runnable来表示这个无名local内部类的type(OO多态)。 例如上面这段代码编译后你会看到其实是编译了两个类来的，如下： 
>
> 
>
> 其中Text2$1就是无名local内部内类，这个也就很好地解释了为什么在main（）方法中new Runnable(){xxx}里面的调用main()方法中的变量的时候要用final关键字来修饰

```java
public class Threads4{
     public static void main(String[] args){
         new Threads4().go();
     }
     public void go(){
         Runnable r=new Runnable(){
             public void run(){
                 System.out.print("foo");
             }
         };
     Thread t=new Thread(r);
     t.start();
     }
 } 
```



匿名内部类：new Runnable(){};其实是匿名内部类的写法，编译器会自动帮我们创建一个实现了接口的匿名内部类，所谓匿名只是对编程人员匿名，并非对虚拟机匿名    

==new Runnable（）{}不是实例化  而是创建匿名内部类==

## 异步执行线程：

> ​    与异步相对的是同步，这里先解释一下同步执行，同步执行就是平时执行我们的代码，由上至下顺序执行，中间如果有异常或错误出现不会继续往下执行。这也是绝大多数代码的执行方式。比如如下代码。
>
> ```java
>  System.out.println("a");
>  Thread.sleep(2000);
>  System.out.println("b");
>  System.out.println("c");
> ```

异步执行的代码相当于是在另外一个线程中执行，它与主线程互不相关，互不干扰。比如在上面的代码中，将第三行代码改为异步执行，即使这一行代码让线程“睡眠”了，或者抛出异常了，主线程依然会正常地继续往下执行。得到的效果就是这样的。

```css

```



## 说说多线程

线程是操作系统调用的最小的单位，可以让进出并发处理多个业务

**使用多线程的原因：**

## 线程和进程的区别:

>  \1. 进程有独立的地址空间,线程有自己的堆栈和局部变量,但线程之间没有单独的地址空间； 
>
>  \2. 进程和线程切换时,需要切换进程和线程的上下文,进程的上下文切换时间开销远远大于线程上下文切换时间,耗费资源较大,效率要差一些；
>
>  \3. 进程的并发性较低,线程的并发性较高；
>
>  \4. 每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口,但是线程不能够独立执行,必须依存在应用程序中,由应用程序提供多个线程执行控制；
>
>  \5. 系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言,除了 CPU 外,系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源）,线程组之间只能共享资源；
>
>  \6. 一个进程崩溃后,在保护模式下不会对其他进程产生影响,但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

## 线程和进程的关系

1、一个进程可以有多个线程，但至少有一个线程；而一个线程只能在一个进程的地址空间内活动。
2、资源分配给进程，同一个进程的所有线程共享该进程所有资源。
3、CPU分配给线程，即真正在处理器运行的是线程。
4、线程在执行过程中需要协作同步，不同进程的线程间要利用消息通信的办法实现同步。

# Thread线程类常用方法

```java
Thread类有以下方法：

-  String getName()：返回该线程的名称。 
-  void setName(String name)：设置线程名称 
-  int getPriority()：获取线程的优先级。 
-  void setPriority(int newPriority)：修改线程的优先级。 
-  boolean isDaemon()：获取该线程是否为守护线程。 
-  void setDaemon(boolean on)：将该线程标记为守护线程或用户线程。 
-  static void sleep(long millis)：线程阻塞 
-  void interrupt()：中断线程。 
-  static void yield()：暂停当前正在执行的线程对象，并执行其他线程。 
-  void join()：等待该线程终止。 
-  void run()：线程的执行体 
-  void start() ：启动线程
```

下面对常用方法做一下简略的演示：

## sleep 阻塞

使当前线程从Running状态放弃处理器进入Block状态,休眠times毫秒，再返回Runnable状态。