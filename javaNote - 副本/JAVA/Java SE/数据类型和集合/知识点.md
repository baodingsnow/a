# 修饰符

将类的成员的访问权限设置为默认的，则该成员能被同一包中的类访问

# 集合特点

![](E:\Sadnote\sad\picture\v2-76c3c04de2e8609c488fa0081fb99c26_1440w.png)



Set: HashSet，LinkedHashSet，TreeSet，EnumSet（后三个有序）

List: ArrayList，LinkedList，Stack，Vector（全部有序）

Queue：LinkedBlockingQueue，ArraysBlockingQueue（全部有序）

Map: HashMap，TreeMap，LinkedHashMap，EnumMap（前三有序），ConcurrentHashMap，IdentityHashMap

首先是List，可以看到ArrayList可以存储多个null，ArrayList底层是数组，添加null并未对他的数据结构造成影响。LinkedList底层为双向链表，`node.value = null`也没有影响。

结果：

List都可以添加null元素

HashMap可以有1个key为null的元素，TreeMap不能有key为null的元素
 Set底层是Map

所以HashSet可以有1个null的元素，TreeSet不能有key为null的元素。



# 值传递与引用传递

Java中原始数据类型都是值传递，传递的是值得副本，形参的改变不会影响实际参数的值， 引用传递传递的是引用类型数据，包括String,数组，列表, map,类对象等类型，形参与实参指向的 是同一内存地址，因此形参改变会影响实参的值。



# 互斥锁定

- **互斥：**指在某一时刻只允许一个进程运行其中的程序片，具有排他性和唯一性。
  对于线程A和线程B来讲，在同一时刻，只允许一个线程对临界资源进行操作，即当A进入临界区对资源操作时，B就必须等待；当A执行完，退出临界区后，B才能对临界资源进行操作。

 采用synchronized修饰符实现的同步机制叫做互斥锁机制，它所获得的锁叫做互斥锁。每个对象都有一个monitor(锁标记)，当线程拥有这个锁标记时才能访问这个资源，没有锁标记便进入锁池。任何一个对象系统都会为其创建一个互斥锁，这个锁是为了分配给线程的，防止打断原子操作。每个对象的锁只能分配给一个线程，因此叫做互斥锁



那什么是临界资源和临界区呢？

- 临界资源：能够被多个线程共享的数据/资源。
- 临界区：对临界资源进行操作的那一段代码



给对象加锁

```java
//首先有个对象，对外部对象加锁
public class SellCinemaTicketThread implements Runnable {
    static int num = 100;
    Object object = new Object();

    @Override
    public void run() {
        while (true) {
            synchronized (object) {
                if (num > 0) {
                    System.out.println(Thread.currentThread().getName() + "买票啦---" + num);
                    num--;
                }
            }

        }
    }
}

```

# jvm 虚拟机

> JVM内存结构主要有三大块：**堆内存**、**方法区**和**栈**
>
> 堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，**Eden空间**、**From Survivor空间**、**To Survivor空间**,默认情况下年轻代按照**8:1:1**的比例来分配；
>
> 方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。
>
> 对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中**最大**的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，**几乎所有的对象实例都在这里分配内存**。

jvm堆分为：新生代（一般是一个Eden区，两个Survivor区），老年代（old区）。

常量池属于 PermGen（方法区）







栈内存中放哪些东西？
 ①基本类型的变量，例如int a=3中的a；
 ②对象的引用变量，例如Thread t=new Thread();中的t。
      当在代码块中定义一个变量时，Java就在栈中为这个变量分配内存空间；当超过变量的作用域后，Java会自动 释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。



2.堆内存中存放哪些东西？
 ① 存放由new创建的对象和数组。
     在堆中存放的内存，由Java虚拟机垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量持有的内容等于数组或者对象在堆内存中的首地址。在栈中的这个特殊的变量，就成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。



# 关于变量初始化

方法中定义的变量一定要初始化，类中定义的变量可不用初始化，会有默认值





# 线程巩固

匿名内部类：new Runnable(){};其实是匿名内部类的写法





# 线程状态

![](E:\Sadnote\sad\picture\4446785_1503915169036_39520A16A8408A5DD25BA09B2BB1BFEE.png)

> 4.wait()、sleep()、yield()的理解
>
> 1）wait()是Object的实例方法，在synchronized同步环境使用，作用当前对象，会释放对象锁，需要被唤醒。
>
> 2）sleep()是Thread的静态方法，不用在同步环境使用，作用当前线程，不释放锁。
>
> 3）yield()是Thread的静态方法，作用当前线程，释放当前线程持有的CPU资源，将CPU让给优先级不低于自己的线程用，调用后进入就绪状态。



创建线程并启动的过程为：定义线程—》实例化线程—》启动线程

**一 、定义线程：** 1、扩展java.lang.Thread类。 2、实现java.lang.Runnable接口。

**二、实例化线程：** 1、如果是扩展java.lang.Thread类的线程，则直接new即可。

​         2、如果是实现了java.lang.Runnable接口的类，则用Thread的构造方法：

​    Thread(Runnable target) 
​    Thread(Runnable target, String name) 
​    Thread(ThreadGroup group, Runnable target) 
​    Thread(ThreadGroup group, Runnable target, String name) 
​    Thread(ThreadGroup group, Runnable target, String name, long stackSize)

**所以A、D的实例化线程错误。**

**三、启动线程：** 在线程的Thread对象上调用start()方法，而不是run()或者别的方法。

# 基本类型

```java
float x = 2;
float xx = 2f;

float x1 = 2.0;  // Error
float x2 = 2.0F; // 定义浮点数不能省略 f（或F）

Float x3 = 2; // Error
Float x4 = 2f; // 一定要加 f 或 F

Float x5 = 2.0; // Error
Float x6 = 2.0f; // 一定要加 f 或 F
```

- 使用包装类型声明一定要加`F`(`f`),
- 使用基本数据类型声明，定义整数可以不加`F`(`f`)，浮点数一定要加



#  继承，调用关系

在调用子类构造器之前，会先调用父类构造器，当子类构造器中没有使用"super(参数或无参数)"指定调用父类构造器时，是默认调用父类的无参构造器，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。



## super关键字

# final修饰符

final关键字可以修饰：

（1）类。类不能被继承。

（2）方法。方法不能被重写，但是可以重载。

（3）基本类型变量。只能被赋值一次，即常量。

（4）引用。只有一次指向对象的机会。

final 变量能被显式地初始化并且只能初始化一次。被声明为 final 的对象的引用不能指向不同的对象。但是 final 对象里的数据可以被改变。也就是说 final 对象的引用不能改变，但是里面的值可以改变。

final 修饰符通常和 static 修饰符一起使用来创建类常量。



> 一个子类只能继承一个父类
>
> 一个接口可以继承多个接口，但实现该接口的实现类也要实现该接口继承的多个接口

# 重写和重载

## 重写:

重写（Override）是父类与子类之间多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Override)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。子类与父类**函数体内容不一样**。子类方法访问修饰符的限制一定要大于父类方法的访问修饰（public>protected>default>private）

## 重载：

重载（Overload）是一个类中多态性的一种表现。如果在一个类中定义了多个同名的方法，它们参数列表不同，则称为方法的重载(Overload)

**区别：**重载实现于一个类中;重写实现于子类中。

# 抽象

> 抽象类中可以没有抽象方法，也可以包含非抽象方法，但有抽象方法的类一定是抽象类。
>
> 抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。
>
> 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。
>
> 父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。
>
> 在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。





- 如果一个类包含抽象方法，那么该类必须是抽象类。
- 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。

继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。

# 中间件

中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/ 服务器的操作系统之上，管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。

（简单来说，中间件并不能提高内核的效率，一般只是负责网络信息的分发处理）

中间件特点的描述：

```sqlite
1. 中间件应支持标准的协议和接口
2. 中间件可运行于多种硬件和操作系统平台上
3. 跨越网络,硬件，操作系统平台的应用或服务可通过中间件透明交互
```



# 异常

> 运行时异常： 都是RuntimeException类及其子类异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。
>
> 常见的运行异常：
>
> NullPointerException(空指针异常)
> IndexOutOfBoundsException(下标越界异常)
> ClassNotFoundException （指定的类不存在）
> NoSuchMethodError (方法不存在错误)
> NumberFormatException (数字格式异常)
> ArrithmeticException(算数异常）
> 运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。
>
> 编译异常： 是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。
>
> 常见的编译异常： IOException（包括FileNotFoundException）、SQLException等以及用户自定义的Exception异常， 一般情况下不自定义检查异常。

![](E:\Sadnote\sad\picture\27B7CB00-D118-4080-A200-BCE50E636A01.png)

要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：

- **检查性异常：**最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。
- **运行时异常：** 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。
- **错误：** 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。

## 捕获异常

使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。

try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：

```java
try
{
   // 程序代码
}catch(ExceptionName e1)
{
   //Catch 块
}
```

# static

看起来内容很多

> 非静态方法无法调用静态成员变量
>
> 静态变量是类成员



# 匿名内部类

# 接口和抽象类的区别

抽象类可以有默认的方法实现完全是抽象的。 接口根本不存在方法的实现。 抽象类中可以有已经实现了的方法，也可以有被abstract修饰的方法（抽象方法），因为存在抽象方法，所以该类必须是抽象类。 但是接口要求只能包含抽象方法，抽象方法是指没有实现的方法。

# 方法和变量

比较笨  还没搞懂

引入

> 因为该类的静态方法是程序启动时自动放在内存中了的，是属于程序的公共内存（但只能访问），而类名在这里你可以理解为命名空间。先通俗的分析下，我们把类看作是一个房子。房子里面有家具，桌椅板凳之类的，房子里面还有人。 房子里面所有的人都应该是共有一套家具的。也就是说，这些家具是唯一的，如果某个家具坏了，那么大家都用不了。 我们再看一看定义，java的静态变量也叫做类变量，它开始于类的创建，结束于类的消亡。非静态变量叫做实例变量，它开始于类的实例的创建，结束语类的实例的消亡。静态变量被所有实例所共享。也就是如上面的例子，座椅板凳是类变量，它们是在房子被建好了之后就被添加放置进来，而且基本都是唯一的。人就相当于实例，每个人都能用这些家具，但是如果家具一旦损坏，那就是坏了，或者你把某一个家具搬走，那么所有的人都用不了这个家具，房子里也不存在这个家具了。 但是房子里可以进很多人，可以进张三，也可以进李四。所以这些人就是类的实例对象，他们身上穿的衣服就可以叫做实例变量。 如果一个类中有静态变量的话，程序首先会把该静态变量加载进内存中，也就是在堆中开辟一个区域专门存放。以后不管你new多少个类的对象，该静态变量永远都是在那里的。也就是说，静态变量在类的初始化一次后，系统就不会为该变量开辟新的内存空间。而每new一个类的对象，系统就会重新在 堆内存中开辟一个新空间来存放该类的实例对象，并且栈中也会有一个新的引用变量去指向它。 静态方法也是类似，但是有一点要强调，静态方法只中不能调用非静态方法。因为被static修饰的方法会首先被Classloader对象先加载进内存，而这个时候可能其它的非静态方法或者变量还没有被加载进来。就好比我现在想做包子，现在面粉被static修饰，首先已经拿到你身边，可是因为包子馅不是static修饰的，所以可能包子馅儿还没运过来，你说怎么做的出包子呢。 被static修饰过的都是随着类的初始化后就产生了，在堆内存中都有一块专门的区域来存放，所以只需要类名点方法名或者变量名即可。而非静态的就必须通过类的对象去调相应的。就像是你想要红色的衣服，你必须是从穿红色的衣服的人的身上拿过来才行，所以你必须找到穿红色衣服的人，也就是类的实例对象，而你如果要去找一个桌子，而桌子就在房间里摆着，你只要进到房间里直接走过去拿来就可以了~
> 



## 变量

成员变量包括类变量和实例变量，在类中方法体外

方法体内的变量为局部变量

## 方法

> 成员方法和构造方法的区别
>
> 一、构造方法
>   1.特点：
>        （1）方法名名必须类名相同
>        （2）没有返回值（方法中不能出现void、return等语句）
>        
>   2.作用：
>        （1）给对象初始化
>
>   3.构造方法的细节：
>        （1）当一个类中没有定义构造函数时，系统会默认添加一个无参的构造方法（看不见，但真实存在）。
>        （2）当在类中自定义构造方法之后，默认的无参构造方法消失（如果需要无参构造方法需手动添加）

构造方法:当一个对象被创建的时候，初始化该对象，方法名与类名相同，没有返回值，默认构造方法的访问修饰符和类的访问修饰符相同(类为 public，构造函数也为 public；类改为 protected，构造函数也改为 protected)。
