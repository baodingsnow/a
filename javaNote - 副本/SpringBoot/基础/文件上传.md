# 准备工作

## 需要用到的注解

@ConfigurationProperties  使用方法，该注解有一个prefix属性，通过指定的前缀，绑定配置文件中的配置，该注解可以放在类上，也可以放在方法上

可以从注解说明中看到，当将该注解作用于方法上时，如果想要有效的绑定配置，那么该方法需要有@Bean注解且所属Class需要有@Configuration注解。

```
//            //增加代码  写入文件
//            FileUtil.writeBytes(file.getBytes(),fileFullPath);
```



## 知识点

### inputstream和fileinputstream的区别

InputStream不可以读取文件，它是一个Abstract的类，根本不可能实例化，是所有输入流的基类。而FileInputStream是InputStream的一个实现类，用于读取诸如图像数据之类的原始字节流。要读取字符流，请考虑使用 FileReader。

> 一般都是 向下转型
>
> InputStream   stream=new FileInputStream

# 文件上传

> 文件上传的基本逻辑
>
> 获取前台上传的file文件 获取文件名（包括格式）  获取指定保存上传文件的根路径 根据根路径和文件名创建新文件  通过输入流循环读取前台的file文件  通过输出流循环将读取到的file文件写入到创建的新文件 关闭输入输出流

 写入文件  使用  file.transferTo 方法   不用再手动关闭输入输出流了



文件上传逻辑最新：

判断是否上传文件   获取上传文件名称和路径   判断路径是否存在  不存在创建路径  

然后进行文件写入     写入文件两种方式   ①MultipartFile对象.transferTo(File对象（包含file的名称和路径）)

②FileUtil（Hutoo工具）.writeBytes(MultipartFile对象.getBytes（），File对象（包含file的名称和路径)）

```java
/**
transferTo方法 写入文件
*/
@PostMapping("/upload")
    public Object upload(@RequestParam("file")MultipartFile file){
        return saveFile(file);
    }


    private Object saveFile(MultipartFile file){
        if (file.isEmpty()){
            return "未选择文件";
        }
        String filename = file.getOriginalFilename(); //获取上传文件原来的名称
        String filePath = "C:\\Users\\GW00273483\\Desktop";
        File temp = new File(filePath);
        if (!temp.exists()){
            temp.mkdirs();
        }

        File localFile = new File(filePath+filename);
        try {
            file.transferTo(localFile); //把上传的文件保存至本地
            System.out.println(file.getOriginalFilename()+" 上传成功");
        }catch (IOException e){
            e.printStackTrace();
            return "上传失败";
        }


        return "ok";
    }
```



# 文件解析

例子比较多  分成了各个小节





## 简单的字节流输入

输入流操作文件

步骤  创建流 选择流 读取 关闭 

```java
public class InputeasyController {
    public static void main(String[] args) {
        File src = new File("lujing");
        try {
            InputStream is = new FileInputStream(src);
            int data1=is.read();
            int data2=is.read();
            is.close();
            System.out.println((char) data1);
            System.out.println((char) data2);
        }catch (FileNotFoundException e){
            e.printStackTrace();
        }catch (IOException e){
            e.printStackTrace();
        }

    }
}
```



> 在java中，可以使用InputStream对文件进行读取，就是字节流的输入。当读取文件内容进程序时，需要使用一个byte数组来进行存储，如此会有如下两个问题：
>
> 1.如何建立合适大小的byte数组，如果已知输入流的大小。
>
> 2.如果不知输入流的大小，则肯定需要建立一个很大的byte数组，那么byte中很可能有空的内容，那么如何正确合适的将byte数组的中的内容输出？



先看第一个问题： 解决之道就是获取输入流的大小，创建此大小的byte数组。

```java
byte[] flash=new byte[1024*10]; //这是创建一个默认大小的输出流

File file=new file("路径");
byte[] flash=new byte[(int)file.length()] //创建合适大小的输出流
```



第二个问题：问题的解决之道就是获得输入流何时结束，它在byte中的尾索引位置。可以通过read()方法实现，read()返回读取的字节内容，当内容为空时返回-1。利用此特征可以解决第二个问题。

```java
public class InputStreamDemo02   
{   
    public static void main(String args[]) throws Exception{   
        File f = new File("E:"+File.separator+"java2"+File.separator+"StreamDemo"+File.separator+"test.txt");   
        InputStream in = new FileInputStream(f);   
        byte b[] = new byte[1024];   
        int len = 0;   
        int temp=0;          //所有读取的内容都使用temp接收   
        while((temp=in.read())!=-1){    //当没有读取完时，继续读取   
            b[len]=(byte)temp;   
            len++;   
        }   
        in.close();   
        System.out.println(new String(b,0,len));   
    }   
} 
```



##  项目代码

项目代码逻辑：批量保存文件功能，首先将中间件id 版本ID，保存至关系表，然后再解析上传的文件，通过遍历的方式

解析上传文件需要根据上传文件id  











根据上传文件的id解析文件   以json格式为例

```java
    
/**

*/
public String getFileStringContentById(Long id) throws Exception {
        String fileContent = null;
        if (id != null) {
            FileInfo fileInfo = this.getById((Serializable) id);
            if (fileInfo != null) {
                try {
                    fileContent = FileUtils.inputStream2String(FileUtils.getInputStream(FileUploadUtils.getRealSavePath(fileInfo.getFilePath())), StandardCharsets.UTF_8.name());
                } catch (Exception e) {
                    log.error(e.getMessage());
                    throw e;
                }
            }
        }
        return fileContent;
    }
```









```java
public static InputStream getInputStream(String filePath) throws Exception {
        InputStream inputStream = null;
        try {
            File file = new File(filePath);
            inputStream = new FileInputStream(file);
        } catch (Exception e) {
            throw e;
        }
        return inputStream;
    }
```

