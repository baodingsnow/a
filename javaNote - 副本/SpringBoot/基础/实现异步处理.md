> 项目报错时后台信息打印的特别慢



本篇文章我们以SpringBoot中异步的使用（包括：异步调用和异步方法两个维度）来进行讲解

# 异步请求与同步请求

我们先通过一张图来区分一下异步请求和同步请求的区别：

![](E:\javaNote\JAVA\picture\202151792213194.jpg)



# Servlet3.0中的异步

Servlet 3.0之前，Servlet采用Thread-Per-Request的方式处理请求，即每一次Http请求都由一个线程从头到尾处理。当涉及到耗时操作时，性能问题便比较明显。

Servlet 3.0中提供了异步处理请求。可以先释放容器分配给请求的线程与相关资源，减轻系统负担，从而增加服务的吞吐量。

Servlet 3.0的异步是通过AsyncContext对象来完成的，它可以从当前线程传给另一个线程，并归还初始线程。新的线程处理完业务可以直接返回结果给客户端。

# 一个简单的异步编程例子



## 	V1.0默认的实现

> @Async注解在默认情况下用的是线，不是真正意义上的线程池。

### Step1 搞配置类，开启@EnableAsync

我们需要使用@EnableAsync来开启异步任务支持。

@EnableAsync注解可以直接放在SpringBoot启动类上，也可以单独放在其他配置类上。

我们这里选择单独搞个配置类

```java
@Configuration
@EnableAsync
public class ThreadPoolTaskConfig {

}
```

### Step2 搞方法标记 @Async注解

```java
package com.artisan.jobs;

import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

/**
 * @author 小工匠
 * @version 1.0
 * @description: TODO
 * @date 2022/3/1 0:42
 * @mark: show me the code , change the world
 */

@Component
@Slf4j
public class AsyncJob {


    @Async 
    public void job1() throws InterruptedException {
        long beginTime = System.currentTimeMillis();
        Thread.sleep(2000);
        long endTime = System.currentTimeMillis();
        log.info("job1 cost {} ms", endTime - beginTime);
    }

    @Async 
    public void job2() throws InterruptedException {
        long beginTime = System.currentTimeMillis();
        Thread.sleep(2000);
        long endTime = System.currentTimeMillis();
        log.info("job2 cost {} ms", endTime - beginTime);
    }
}
```

### Step3 搞调用

```java
package com.artisan.controller;

import com.artisan.jobs.AsyncJob;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author 小工匠
 * @version 1.0
 * @description: TODO
 * @date 2022/3/1 0:44
 * @mark: show me the code , change the world
 */

@RestController
@RequestMapping("/async")
@Slf4j
public class AsyncController {


    @Autowired
    private AsyncJob asyncJob;

    @RequestMapping("/job")
    public String task() throws InterruptedException {
        long beginTime = System.currentTimeMillis();

        // 执行异步任务
        asyncJob.job1();
        asyncJob.job2();

        // 模拟业务耗时
        Thread.sleep(1000);


        long cost = System.currentTimeMillis() - beginTime;
        log.info("main cost {} ms", cost);

        return "Task Cost " + cost + " ms";
    }
}
```

```
@Async注解在默认情况下用的是线，不是真正意义上的线程池。
```

可以称之为简单线程异步执行器

## Spring提供的线程池

| 名称                    | 说明                                                         |
| :---------------------- | :----------------------------------------------------------- |
| 简单异步任务Excutor     | 这个类没有实现异步调用，只是一个同步操作。 只适用于不需要多线程的地 |
| 并发任务Executor        | Executor的适配类，不推荐使用。 如ThreadPoolTaskExecutor不满足要求时，才用考虑使用这个类 |
| ThreadPoolTaskScheduler | 可以使用cron表达式                                           |
| 线程池任务加速器        | 推荐。 是对java.util.concurrent.ThreadPoolExecutor的包装     |

## V2.0 实现@Async的自定义线程池

```java
package com.artisan.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.ThreadPoolExecutor;

/**
 * @author 小工匠
 * @version 1.0
 * @description: 使用@EnableAsync来开启异步任务支持，@EnableAsync注解可以直接放在SpringBoot启动类上，也可以单独放在其他配置类上。
 * 我们这里选择使用单独的配置类AsyncConfiguration。
 * @date 2022/3/1 0:41
 * @mark: show me the code , change the world
 */

@Configuration
@EnableAsync
public class ThreadPoolTaskConfig {

    /**
     * 核心线程数（默认线程数）
     */
    private static final int CORE_POOL_SIZE = 5;
    /**
     * 最大线程数
     */
    private static final int MAX_POOL_SIZE = 10;
    /**
     * 允许线程空闲时间（单位：默认为秒）
     */
    private static final int KEEP_ALIVE_TIME = 10;
    /**
     * 缓冲队列大小
     */
    private static final int QUEUE_CAPACITY = 200;
    /**
     * 线程池名前缀
     */
    private static final String THREAD_NAME_PREFIX = "Async-Service-";


    /**
     * 自定义线程池
     *
     * @return
     */
    @Bean("customAsyncPoolTaskExecutor")
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(CORE_POOL_SIZE);
        executor.setMaxPoolSize(MAX_POOL_SIZE);
        executor.setQueueCapacity(KEEP_ALIVE_TIME);
        executor.setKeepAliveSeconds(QUEUE_CAPACITY);
        executor.setThreadNamePrefix(THREAD_NAME_PREFIX);
        /**
         * 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略
         * 通常有以下四种策略：
         * ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
         * ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。
         * ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
         * ThreadPoolExecutor.CallerRunsPolicy：重试添加当前的任务，自动重复调用 execute() 方法，直到成功
         */
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }



}
```

讲一下上面的配置

```java
@Configuration 的作用是表明这是一个配置类。
@EnableAsync 的作用是启用 SpringBoot 的异步执行
    
    
    
    其次，关于线程池的设置有

corePoolSize: 核心线程数，当向线程池提交一个任务时池里的线程数小于核心线程数，那么它会创建一个线程来执行这个任务，一直直到池内的线程数等于核心线程数
maxPoolSize: 最大线程数，线程池中允许的最大线程数量。关于这两个数量的区别我会在下面解释
queueCapacity: 缓冲队列大小，用来保存阻塞的任务队列（注意这里的队列放的是任务而不是线程）
keepAliveSeconds: 允许线程存活时间（空闲状态下），单位为秒，默认60s
namePrefix: 线程名前缀
RejectedExecutionHandler: 拒绝策略，当线程池达到最大线程数时，如何处理新任务。线程池为我们提供的策略有

AbortPolicy：默认策略。直接抛出 RejectedExecutionException
DiscardPolicy：直接丢弃掉被拒绝的任务，且不会抛出任何异常
DiscardOldestPolicy：丢弃掉队列中的队头元素（也就是最早在队列里的任务），然后重新执行 提交该任务 的操作
CallerRunsPolicy：由主线程自己来执行这个任务，该机制将减慢新任务的提交



关于 corePoolSize 与 maxPoolSize 的区别也是困惑了我很久，官方文档上的解释说的很清楚。我的理解如下：
这个线程池其实是有点“弹性的”。当向线程池提交任务时：


若 当前运行的线程数 < corePoolSize
则 即使其它的工作线程处于空闲状态，线程池也会创建一个新线程来执行任务


若 corePoolSize < 当前运行的线程数 < maxPoolSize


若 队列已满
则 创建新线程来执行任务


若 队列未满
则 加入队列中




若 当前运行的线程数 > maxPoolSize


若 队列已满
则 拒绝任务


若 队列未满
则 加入队列中




所以当想要创建固定大小的线程池时，将 corePoolSize 和 maxPoolSize 设置成一样就行了。
最后，别忘了给方法加上 @Bean 注解，否则 SpringBoot 不会加载。
这里因为我加了 @Value 注解，可以在 application.properties 中配置相关数据，如


```



## V3.0 多个线程池处理

需求： 不同的业务，使用不同的线程池

### 多个线程池

```java
package com.artisan.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.ThreadPoolExecutor;

/**
 * @author 小工匠
 * @version 1.0
 * @description: 使用@EnableAsync来开启异步任务支持，@EnableAsync注解可以直接放在SpringBoot启动类上，也可以单独放在其他配置类上。
 * 我们这里选择使用单独的配置类ThreadPoolTaskConfig
 * @date 2022/3/1 0:41
 * @mark: show me the code , change the world
 */

@Configuration
@EnableAsync
public class ThreadPoolTaskConfig {

    /**
     * 核心线程数（默认线程数）
     */
    private static final int CORE_POOL_SIZE = 5;
    /**
     * 最大线程数
     */
    private static final int MAX_POOL_SIZE = 10;
    /**
     * 允许线程空闲时间（单位：默认为秒）
     */
    private static final int KEEP_ALIVE_TIME = 10;
    /**
     * 缓冲队列大小
     */
    private static final int QUEUE_CAPACITY = 200;
    /**
     * 线程池名前缀
     */
    private static final String THREAD_NAME_PREFIX = "Biz1_Async-Service-";

    /**
     * 线程池名前缀
     */
    private static final String THREAD_NAME_PREFIX_2= "Biz2_Async-Service-";

    /**
     * 自定义线程池
     *
     * @return
     */
    @Bean("tp1")
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(CORE_POOL_SIZE);
        executor.setMaxPoolSize(MAX_POOL_SIZE);
        executor.setQueueCapacity(KEEP_ALIVE_TIME);
        executor.setKeepAliveSeconds(QUEUE_CAPACITY);
        executor.setThreadNamePrefix(THREAD_NAME_PREFIX);
        /**
         * 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略
         * 通常有以下四种策略：
         * ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
         * ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。
         * ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
         * ThreadPoolExecutor.CallerRunsPolicy：重试添加当前的任务，自动重复调用 execute() 方法，直到成功
         */
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }


    /**
     * 自定义线程池
     *
     * @return
     */
    @Bean("tp2")
    public ThreadPoolTaskExecutor taskExecutor2() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(CORE_POOL_SIZE);
        executor.setMaxPoolSize(MAX_POOL_SIZE);
        executor.setQueueCapacity(KEEP_ALIVE_TIME);
        executor.setKeepAliveSeconds(QUEUE_CAPACITY);
        executor.setThreadNamePrefix(THREAD_NAME_PREFIX_2);
        /**
         * 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略
         * 通常有以下四种策略：
         * ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
         * ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。
         * ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
         * ThreadPoolExecutor.CallerRunsPolicy：重试添加当前的任务，自动重复调用 execute() 方法，直到成功
         */
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }

}
```

**配置 多个线程池， 然后 为@Async指定线程池名字即可实现 多个线程池处理**

### 默认线程池

@Async()没标注，用哪个？？？？？？  当系统存在多个线程池时，我们也可以配置一个默认线程池 ，配置类让其实现AsyncConfigurer，并重写getAsyncExecutor()方法，指定默认线程池

```java
package com.artisan.multi;

import lombok.extern.slf4j.Slf4j;
import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;

import java.util.concurrent.Executor;
import java.util.concurrent.ThreadPoolExecutor;

/**
 * @author 小工匠
 * @version 1.0
 * @mark: show me the code , change the world
 * 
 * 实现AsyncConfigurer，并重写getAsyncExecutor()方法，指定默认线程池
 */

@Configuration
@EnableAsync
@Slf4j
public class DefaultAsyncConfiguration implements AsyncConfigurer {


    /**
     * 核心线程数（默认线程数）
     */
    private static final int CORE_POOL_SIZE = 2;
    /**
     * 最大线程数
     */
    private static final int MAX_POOL_SIZE = 10;
    /**
     * 允许线程空闲时间（单位：默认为秒）
     */
    private static final int KEEP_ALIVE_TIME = 10;
    /**
     * 缓冲队列大小
     */
    private static final int QUEUE_CAPACITY = 200;
    /**
     * 线程池名前缀
     */
    private static final String THREAD_NAME_PREFIX = "Default_Async-Service-";


    @Bean(name = "defaultPool")
    public ThreadPoolTaskExecutor executor() {
        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
        taskExecutor.setCorePoolSize(CORE_POOL_SIZE);
        taskExecutor.setMaxPoolSize(MAX_POOL_SIZE);
        taskExecutor.setQueueCapacity(KEEP_ALIVE_TIME);
        taskExecutor.setKeepAliveSeconds(QUEUE_CAPACITY);
        taskExecutor.setThreadNamePrefix(THREAD_NAME_PREFIX);
        /**
         * 当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略
         * 通常有以下四种策略：
         * ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。
         * ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。
         * ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
         * ThreadPoolExecutor.CallerRunsPolicy：重试添加当前的任务，自动重复调用 execute() 方法，直到成功
         */
        taskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        taskExecutor.initialize();
        return taskExecutor;
    }

    /**
     * 指定默认线程池
     */
    @Override
    public Executor getAsyncExecutor() {
        return executor();
    }

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return (ex, method, params) -> log.error("线程池执行任务发横未知错误,执行方法：{}", method.getName(), ex);
    }




}
```

### 验证一把

```java
@RestController
@RequestMapping("/async")
@Slf4j
public class AsyncController {


    @Autowired
    private AsyncJob asyncJob;

    @RequestMapping("/job")
    public String task() throws InterruptedException {
        long beginTime = System.currentTimeMillis();

        // 执行异步任务
        asyncJob.job1();
        asyncJob.job2();
        asyncJob.job3();

        // 模拟业务耗时
        Thread.sleep(1000);


        long cost = System.currentTimeMillis() - beginTime;
        log.info("main cost {} ms", cost);

        return "Task Cost " + cost + " ms";
    }
}
```

# java异步方法调用2

> 主要以创建线程的方式实现异步处理



伪代码

```java
//我们需要执行的代码1
longTimeMethod();
//我们需要执行的代码2
```

如上，如果我们执行到longTimeMethod的时候，必须等待这个方法彻底执行完才能执行“我们需要执行的代码2”，但是如果二者的关联性不是那么强，其实是没有必要去等待longTimeMethod执行完的。

**那么异步执行如何解决以上问题呢?**

 采用多线程把longTimeMethod 封装到一个多线程中，让它去执行

```java
Thread t = new Thread(){
  @Override
  public void run() {
    longTimeMethod();
  }
};
```

其他类调用这个方法。这里注意，一定要其他的类，如果在同类中调用，是不生效的。具体原因，可以去学习一下Spring AOP的原理

```java
@Autowired
private AsynchronousService asynchronousService;

public void useAsynchronousMethod(){
  //我们需要执行的代码1
  asynchronousService.springAsynchronousMethod();
 //我们需要执行的代码2
}
```

**那么问题来了，以上异步调用的方法都是没有返回值的，如果有返回值的方法该怎么获取到返回值呢？**

## 非异步的写法

```java
//我们需要执行的代码1
Integer result = longTimeMethod();
//我们需要执行的代码2
```

## 采用JDK原生的Future类

```java
//我们需要执行的代码1
Future future = longTimeMethod2();
//我们需要执行的代码2
Integer result = future.get();
```

可以看到，我们调用longTimeMethod2返回一个Future对象（注意了，这里的longTimeMethod2当然不是上面的longTimeMethod），然后处理“我们需要执行的代码2”，到了需要返回结果的时候直接调用future.get()便能获取到返回值。下面我们来看看longTimeMethod2如何实现。

```java
private Future longTimeMethod2() {
  //创建线程池
  ExecutorService threadPool = Executors.newCachedThreadPool();
  //获取异步Future对象
  Future future = threadPool.submit(new Callable() {
    @Override
    public Integer call() throwsException {
        return longTimeMethod();
    }
  });
  return future;
}
```

可以看到我们用到了线程池，把任务加入线程池中，返回Future对象。其实我们调用longTimeMethod2方法是开启了其他的线程，其他的线程在调用工作。

对于Future来说，除了无参的get()方法之外，还有一个有参的get()方法。有参的get()方法中传入的参数是需要等待的时间，也就是超时设置，不需要一直等待下去。而我们返回的Future对象是FutureTask的实例。

## 采用Spring的异步方法执行

1. 先把longTimeMethod 封装到Spring的异步方法中，这个异步方法的返回值是Future的实例。这个方法一定要写在Spring管理的类中，注意注解@Async。

```java
@Service
public class AsynchronousService{
  @Async
  public Future springAsynchronousMethod(){
    Integer result = longTimeMethod();
    return new AsyncResult(result);
  }
}
```

2.其他类调用这个方法。这里注意，一定要其他的类，如果在同类中调用，是不生效的

```java
@Autowired
private AsynchronousService asynchronousService;

public void useAsynchronousMethod(){
    Future future = asynchronousService.springAsynchronousMethod();
    future.get(1000, TimeUnit.MILLISECONDS);
}
```

其实Spring只不过在原生的Future中进行了一次封装，我们最终获得的还是Future实例。

# 问题 

做项目时遇到问题

> 异步实现主要通过bean装配实现
>
> 项目中需要在serviceImpl层调用需要异步的方法，所以需要对相应的service方法添加@Async注解
>
> 我觉得 自己的service无法注入到自己的serviceImpl 否则会报错

