# 确认审核和审核通过







1.获取以下信息

```
projectDataSetList:根据项目编号查出数据集列表
projectDataSetMap:根据项目编号查出数据集列表，在根据埋点事件编号对列表进行分组，一定只有一个，因为一个编号对应一个数据集
```

```
bmUserDataMap:根据项目编号查出用户列表，根据三id+原表名进行分组
```

```
dataDocumentList:上传excel 导出的数据列表
map:根据三id+原表名进行分组
```

声明变量

```
buryPointNoSet  盛放 保存数据集的buryPointNo     用来判断数据库和userData中是否有数据集没有保存上
```

```
lastVersionDeletedSet :  更新数据集时，新增一条最新的数据集，删除上一个版本， 这个变量就是用来盛放 删除的数据集的id的
```

```
newSaveFieldMap:
```



## 开始遍历map

2.新数据 buryPointNo 和 dataSetNo的对应关系

```
val：对map进行遍历 。得到上传文件每个三id+原表名进行分组的list数据
dataDocument:取val中的一个实体
buryPointNo：该实体的埋点事件编号(不确定在数据库中是否有定义)
bmBuryPointDefinition: 根据buryPointNo查询埋点事件定义表(不一定存在)
bmBuryPointDetail:根据buryPointNo,上传附件的模糊字段filedCode模糊查询埋点事件详情表(不一定存在)
```





==从这里到遍历val都是为了保存数据集==

判断:

> bmBuryPointDefinition为空的话，说明管理员上传的文件不正确，跳出此次遍历 ，开始下一个excel集合的遍历
>
> bmBuryPointDetail同上  
>
> 不为空继续执行

```
bmProjectDataSet:创建一个数据集类型的对象，用dataDocument赋上对应的数据，用来保存至dataSet表中
```





继续判断:

> ​                    根据项目编号查出数据集列表projectDataSetList为空，说明本次是 审核通过操作，直接保存即可

否则:  (确认审核操作)

> ​      
>
> ```
> dbBmProjectDataSet   根据buryPointNo,即遍历excel得到的本条数据集对应的埋点事件编号 ， 得到projectDataSetMap对应的value，即db中的对应的buryPointNo的数据集
> ```
>
> ==dbBmProjectDataSet==
>
> 判断 ：
>
> ​         如果 dbBmProjectDataSet不为空  {说明之前数据集存在，bmProjectDataSet，继续对这个对象插入数据，setVersion,    setDataSetId ，然后保存，然后处理上一个版本的数据集，即根据id删除，   最后lastVersionDeletedSet添加埋点事件编号}    
>
> ==这里有个问题，因为先执行的保存，再删除，会不会把之前保存的数据集也删掉==
>
> R:不会 ，因为保存新的数据集是新的id 和旧id不冲突
>
> ​    如果为空 {直接保存}
>
>   

 



继续执行遍历excel数据集后面的操作

```
tempList: List<BmProjectDataSetField> tempList = new ArrayList<>();
用来保存数据集属性
```

遍历val

> ```
> tempDocument   遍历得到的DataDocument类型的对象  
> ```
>
> BmProjectDataSetField bmProjectDataSetField  用来保存数据集属性 到db
>
> 直接调用服务保存bmProjectDataSetField  ，  tempList添加bmProjectDataSetField  那么上面的tempList有什么用，看下面的说明

newSaveFieldMap添加(埋点事件编号,tempList)







更新项目状态和审核状态





求差集

遍历bmUserDataMap.keySet()，即userdata表中数据集分组key userDataBuryPointNo

> 判断bmUserDataMap中的遍历的数据集编号在不在管理员上传的excel中
>
>  如果在   说明管理员上传的excel的这条数据集和之前用户上传的 是同一个数据集 {
>
> ​                 判断属性是否重复
>
> ```
> List<BmProjectDataSetField> bmProjectDataSetFieldList
> 用来盛放数据集属性 , userDataBuryPointNo作为key  从newSaveFieldMap中获取     即从之前 保存管理员excel中的数据集属性列表中，通过userDataBuryPointNo获取数据集属性列表
> List<String> existFieldCode   获取上面属性列表的FieldCode
> 
> 
> List<BmUserData> userDataList   获取userData表中对应数据集的list  
>         for (BmUserData bmUserData : userDataList) {
>                     if (existFieldCode.contains(bmUserData.getFieldCode())) {
>                         continue;
>                     }  
>                     只对比fieldCode就可以了  因为别的都是可以改变的
> 如果重复  继续执行for循环      不重复，说明之前有的用户数据，管理员没有上传  根据数据集编号重新构造一个BmProjectDataSetField对象并保存
> ```
>
> 如果不在   说明管理员没有采用用户上传的数据集   
>
> ​         buryPointNoSet(管理员上传的文件中的埋点事件编号集合)+用户上传但是管理员没上传的埋点事件编号
>
> ```
> curBuryPointUserDataList   盛放用户上传但是管理员没上传的埋点事件编号的数据集属性
> 保存数据集 + 保存数据集属性
> 
> ```
>
> ==这里有个大问题，用户提交的脏数据，也在这里直接保存了；是不是也要校验一下在数据库中是否存在==
>
> 
>
> }                